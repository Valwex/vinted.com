import { metrics } from '@opentelemetry/api';
import { Resource } from '@opentelemetry/resources';
import { MeterProvider, PeriodicExportingMetricReader, } from '@opentelemetry/sdk-metrics';
import { AggregationTemporalityPreference, OTLPMetricExporter, } from '@opentelemetry/exporter-metrics-otlp-http';
const EXPORT_INTERVAL_MS = 30_000;
class ClientMetrics {
    isServerSide = typeof window === 'undefined';
    isEnabled = typeof window === 'undefined';
    collectorUrl = 'unknown';
    serviceName = 'unknown';
    token = '';
    environment = undefined;
    version = undefined;
    shouldUseBeacon = false;
    hasFlushed = false;
    metricReaders = [];
    #setupProperties({ serviceName, env, version, collectorUrl, samplingRate = 1, token, shouldUseBeacon = false, }) {
        this.collectorUrl = collectorUrl;
        this.serviceName = serviceName;
        this.shouldUseBeacon = shouldUseBeacon;
        this.environment = env;
        this.version = version;
        this.token = token;
        this.isEnabled = !this.isServerSide && Math.random() <= samplingRate;
    }
    #getResource() {
        const { serviceName, environment: env, version } = this;
        return Resource.default().merge(new Resource({
            'service.name': serviceName,
            version,
            env,
        }));
    }
    #getReaders() {
        const { collectorUrl, shouldUseBeacon, token } = this;
        const headers = {
            'Content-Type': 'application/json',
        };
        if (!shouldUseBeacon && token) {
            headers.Authorization = `Bearer ${this.token}`;
        }
        const url = shouldUseBeacon
            ? `${collectorUrl}/v1/metrics?key=${token}`
            : `${collectorUrl}/v1/metrics`;
        const exporterConfig = {
            url,
            concurrencyLimit: 1,
            temporalityPreference: AggregationTemporalityPreference.DELTA,
            headers: shouldUseBeacon ? undefined : headers,
        };
        const readers = [
            new PeriodicExportingMetricReader({
                exporter: new OTLPMetricExporter(exporterConfig),
                exportIntervalMillis: EXPORT_INTERVAL_MS,
            }),
        ];
        return readers;
    }
    #onVisibilityChange = () => {
        if (document.visibilityState === 'hidden') {
            if (this.hasFlushed)
                return;
            this.hasFlushed = true;
            this.metricReaders.forEach(reader => reader.forceFlush());
        }
        else {
            this.hasFlushed = false;
        }
    };
    #onPageClose = () => {
        this.hasFlushed = true;
        this.metricReaders.forEach(reader => reader.shutdown());
    };
    initialize(options) {
        this.#setupProperties(options);
        if (!this.isEnabled)
            return;
        if (!this.isServerSide) {
            document.addEventListener('visibilitychange', this.#onVisibilityChange);
            window.addEventListener('pagehide', this.#onPageClose);
            window.addEventListener('beforeunload', this.#onPageClose);
        }
        const resource = this.#getResource();
        this.metricReaders = this.#getReaders();
        const meterProvider = new MeterProvider({
            resource,
            readers: this.metricReaders,
        });
        metrics.setGlobalMeterProvider(meterProvider);
    }
    counter({ name, value, labels, unit }) {
        if (!this.isEnabled)
            return;
        const meter = metrics.getMeter(name);
        const counter = meter.createCounter(name, {
            unit,
        });
        counter.add(value, { ...labels });
    }
    gauge({ name, value, labels, unit }) {
        if (!this.isEnabled)
            return;
        const meter = metrics.getMeter(name);
        const gauge = meter.createObservableGauge(name, {
            unit,
        });
        gauge.addCallback(result => {
            result.observe(value, { ...labels });
        });
    }
    histogram({ name, value, buckets, labels, unit }) {
        if (!this.isEnabled)
            return;
        const meter = metrics.getMeter(name);
        const histogram = meter.createHistogram(name, {
            unit,
            advice: {
                explicitBucketBoundaries: buckets,
            },
        });
        histogram.record(value, { ...labels });
    }
}
const clientMetrics = new ClientMetrics();
export default clientMetrics;
