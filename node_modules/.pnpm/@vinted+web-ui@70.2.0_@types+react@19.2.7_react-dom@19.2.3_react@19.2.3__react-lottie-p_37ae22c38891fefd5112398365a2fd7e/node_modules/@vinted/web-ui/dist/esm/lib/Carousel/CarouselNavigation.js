import _mapInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/map';
import _fillInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/fill';
import _Object$assign from '@babel/runtime-corejs3/core-js-stable/object/assign';
import { useRef, useEffect } from 'react';
import { c as classNames } from '../../shared/bind-4e2c8c3c.js';
import { KeyboardKey } from '../../constants/keyboard.js';
import { s as styles } from '../../shared/Carousel-ab14e8b1.js';
import { nextIndex, previousIndex } from './utils.js';
import { jsx } from 'react/jsx-runtime';

var CAROUSEL_NAVIGATION_STYLING_VALUES = ['floating'];
/* ---------- Back-compat shims (public API) ---------- */
var CAROUSEL_NAVIGATION_STYLING = {
  Floating: 'floating'
};

/* ---------- Type definitions ---------- */
var CAROUSEL_BULLET_SIZE = parseInt(styles['bullet-container-size'], 10);
var cssClasses = classNames.bind(styles);
var CarouselNavigationBase = function CarouselNavigationBase(_ref) {
  var _context, _context2;
  var styling = _ref.styling,
    activeSlide = _ref.activeSlide,
    slidesCount = _ref.slidesCount,
    _ref$isInfinite = _ref.isInfinite,
    isInfinite = _ref$isInfinite === void 0 ? false : _ref$isInfinite,
    onBulletSelect = _ref.onBulletSelect;
  var navigation = useRef(null);
  useEffect(function () {
    if (!navigation.current) return;
    navigation.current.scrollLeft = CAROUSEL_BULLET_SIZE * (activeSlide - 2);
  }, [navigation, activeSlide]);
  function renderBullet(_, index) {
    var isActive = index === activeSlide;
    var bulletClass = cssClasses(styles.bullet, {
      active: isActive,
      clickable: !!onBulletSelect,
      neighbour: Math.abs(activeSlide - index) === 1,
      'far-neighbour': Math.abs(activeSlide - index) === 2
    });
    function onClick() {
      if (activeSlide === index) return;
      onBulletSelect === null || onBulletSelect === void 0 || onBulletSelect(index);
    }
    function handleKeyDown(event) {
      var newIndex;
      if (KeyboardKey.Right === event.key || KeyboardKey.ArrowRight === event.key) {
        newIndex = nextIndex(index, slidesCount, isInfinite);
      } else if (KeyboardKey.Left === event.key || KeyboardKey.ArrowLeft === event.key) {
        newIndex = previousIndex(index, slidesCount, isInfinite);
      }
      if (newIndex !== undefined) {
        var _navigation$current;
        onBulletSelect === null || onBulletSelect === void 0 || onBulletSelect(newIndex);
        var element = (_navigation$current = navigation.current) === null || _navigation$current === void 0 ? void 0 : _navigation$current.childNodes[newIndex];
        if (element && element instanceof HTMLElement) element.focus();
      }
    }
    return /*#__PURE__*/jsx("li", {
      "data-testid": "carousel-bullet-".concat(index),
      className: bulletClass,
      onClick: onClick,
      onKeyDown: handleKeyDown,
      "aria-label": "carousel-navigation",
      tabIndex: isActive ? 0 : -1,
      role: "menuitem"
    }, index);
  }
  var navigationClass = cssClasses(styles.navigation, styling);
  return /*#__PURE__*/jsx("ul", {
    className: navigationClass,
    role: "menu",
    ref: navigation,
    children: _mapInstanceProperty(_context = _fillInstanceProperty(_context2 = Array(slidesCount)).call(_context2, 1)).call(_context, renderBullet)
  });
};

/** The public component type: a React component value that also has deprecated statics */

/** Exported component: arrow fn + statics, deprecations intact, docgen-friendly */
var CarouselNavigation = _Object$assign(CarouselNavigationBase, {
  /** @deprecated Use string unions, e.g. styling="floating" */
  Styling: CAROUSEL_NAVIGATION_STYLING
});

export { CAROUSEL_NAVIGATION_STYLING, CAROUSEL_NAVIGATION_STYLING_VALUES, CarouselNavigation, CarouselNavigation as default };
//# sourceMappingURL=CarouselNavigation.js.map
